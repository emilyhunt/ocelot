{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>ocelot</code> is in development!","text":"<p>This project is a spin-out from code that I wrote during my PhD. It's currently in alpha / active development.</p>"},{"location":"#which-parts-of-ocelot-are-ready-to-use","title":"Which parts of ocelot are ready to use?","text":"<p>The following parts of the library have stable APIs, and are ready to use in production code:</p> <ul> <li>ocelot.simulate - for simulating star clusters.</li> <li>ocelot.model - various models useful to users of star clusters</li> </ul> <p>The following parts are likely to be completely overhauled in the next few months:</p> <ul> <li>ocelot.calculate</li> <li>ocelot.cluster</li> <li>ocelot.crossmatch</li> <li>ocelot.isochrone</li> </ul> <p>With that in mind, check out how to install ocelot.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v046-relax-version-constraints","title":"v0.4.6: Relax version constraints","text":"<p>Bugfix release that relaxes some version constraints, including allowing for support of e.g. astropy 7.0.</p>"},{"location":"changelog/#v045-bugfix-to-cluster-simulation","title":"v0.4.5: Bugfix to cluster simulation","text":"<p>Fixes a regression added in a previous release that prevented simulation of clusters observed with Gaia. </p> <p>... remember: always run your unit tests! \ud83e\udd74</p>"},{"location":"changelog/#v044-bugfix-for-cluster-simulation-when-zero-stars-simulated","title":"v0.4.4: Bugfix for cluster simulation when zero stars simulated","text":"<p>Two changes to how simulated clusters handle having zero stars were made.</p> <ul> <li>When zero stars are simulated, <code>ocelot.simulate.SimulatedCluster</code> now raises a <code>NotEnoughStarsError</code> (defined in <code>ocelot.simulate.errors</code>), making it easier to catch when no stars were simulated.</li> <li>When cluster pre-pruning causes zero stars to be simulated, <code>ocelot.simulate.SimulatedCluster</code> now also raises a <code>NotEnoughStarsError</code> (previously, this behaviour was undefined.)</li> </ul>"},{"location":"changelog/#v043-improvements-to-gaia-cluster-simulation","title":"v0.4.3: Improvements to (Gaia) cluster simulation","text":"<p>A couple of improvements were made to cluster simulation:</p> <ul> <li><code>ocelot.model.observation.BaseObservation</code> now has two additional default methods for applying photometric and astrometric errors. These can be overwritten for observation types that require additional functionality beyond simple Gaussian errors.</li> <li>The <code>GaiaDR3ObservationModel</code> class now uses this photometric data overwrite to model underestimated BP and RP fluxes in Gaia DR3, slightly improving the realism of cluster CMDs further.</li> </ul>"},{"location":"changelog/#v042-limit-python-version","title":"v0.4.2: Limit Python version","text":"<p>This is a quick release to limit our Python version to below 3.13, as it seems some of our dependencies don't support it yet.</p>"},{"location":"changelog/#v041-move-imf-to-optional-dependency","title":"v0.4.1 - Move IMF to optional dependency","text":"<p>The imf library has been moved to be an optional dependency to try and fix issues with PyPI upload failing.</p>"},{"location":"changelog/#v040-addition-of-cluster-simulation-code-and-models","title":"v0.4.0 - Addition of cluster simulation code and models","text":"<p>This release brings a brand new, sophisticated API for cluster simulation, in addition to optimized models covering a number of different aspects of star cluster science. Additions include:</p> <ul> <li>The new <code>ocelot.simulate</code> submodule for simulating clusters, including:<ul> <li>The flexible and hackable <code>SimulatedCluster</code> class. Extensive code optimizations allow for most open clusters to have full simulations (even randomly sampling the orbits of their binary stars to see if they would or wouldn't be resolved!) in less than a second</li> <li>New <code>SimulatedClusterParamters</code>, <code>SimulatedClusterModels</code>, and <code>SimulatedClusterFeatures</code> dataclasses for controlling <code>SimulatedCluster</code> functionality</li> <li>Ability to simulate observations of simulated clusters, allowing the same simulated cluster to be 'observed' by many different telescopes</li> </ul> </li> <li>The new <code>ocelot.model</code> submodule for star cluster models, including:<ul> <li>A model of King 1962 empirical star clusters. Currently limited to sampling clusters in 3D</li> <li>A bespoke model of differential extinction that approximates dust structure with fractal noise</li> <li>A heavily optimized implementation of the Moe &amp; DiStefano 2017 binary star models</li> <li>Models for selection functions due to observations, such as an optimized implementation of the Castro-Ginard 2023 subsample selection function that can be used to model any generic subsample of stars</li> <li>A model for star cluster observations with Gaia</li> </ul> </li> <li>Extensive unit tests to assure the reliability and accuracy of simulated clusters and their models</li> <li>Documentation improvements, including the first tutorial in the module</li> <li>Refactoring of some old aspects of the module</li> </ul> <p>The APIs of <code>ocelot.simulate</code> and <code>ocelot.model</code> are now the first stable APIs of ocelot, and are ready to use in production code.</p>"},{"location":"citation/","title":"Citing ocelot","text":"<p>There is currently no paper associated with <code>ocelot</code>. For now, please at least mention the package and add a footnote to your mention, linking to this repository - in LaTeX, that would be:</p> <pre><code>\\footnote{\\url{https://github.com/emilyhunt/ocelot}}\n</code></pre> <p>You can also cite Hunt &amp; Reffert 2021, which was the paper for which development of this module began:</p> <pre><code>@ARTICLE{2021A&amp;A...646A.104H,\n       author = {{Hunt}, Emily L. and {Reffert}, Sabine},\n        title = \"{Improving the open cluster census. I. Comparison of clustering algorithms applied to Gaia DR2 data}\",\n      journal = {\\aap},\n     keywords = {methods: data analysis, open clusters and associations: general, astrometry, Astrophysics - Astrophysics of Galaxies, Astrophysics - Solar and Stellar Astrophysics},\n         year = 2021,\n        month = feb,\n       volume = {646},\n          eid = {A104},\n        pages = {A104},\n          doi = {10.1051/0004-6361/202039341},\narchivePrefix = {arXiv},\n       eprint = {2012.04267},\n primaryClass = {astro-ph.GA},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2021A&amp;A...646A.104H},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}\n</code></pre>"},{"location":"developing/","title":"I want <code>ocelot</code> to be a community package.","text":"<p>Star clusters are some of the most useful objects in astronomy.</p> <p>It makes sense to have an open source library of Python tools to work with them!</p> <p>If you like that philosophy, then this project is always open to contributions. Got a feature you'd like to see added? Open up a GitHub issue and we'll think about how we can do it!</p>"},{"location":"features/","title":"Features","text":"<p>ocelot is still in development, so there is a lot left to add!</p> <p>As of the time of writing (January 2025), cluster simulation is the most finished part of the module. I recommend checking out the tutorial notebook for an overview of how it works.</p>"},{"location":"installation/","title":"Installation","text":"<p>Installing ocelot is (relatively) easy!</p> <p>Firstly, install from pip with:</p> <pre><code>pip install ocelot\n</code></pre> <p>to get started, which will install the latest release of the code.</p>"},{"location":"installation/#getting-additional-data","title":"Getting additional data","text":"<p>To use ocelot.simulate, you will also need to install some additional data (namely, isochrones). Download this folder of isochrones, extract it, and place it anywhere you'd like.</p> <p>When running ocelot, you'll need to set the environment variable <code>OCELOT_DATA</code> to point towards your data.</p> <p>... and that's it! Next off, check out ocelot's best bits to see what ocelot can do.</p>"},{"location":"issue/","title":"Report an issue","text":"<p>If you encounter a problem with ocelot, please report it on GitHub.</p>"},{"location":"api/calculate/","title":"Calculate","text":""},{"location":"api/calculate/#work-in-progress","title":"Work in Progress","text":"<p>The full API of <code>ocelot</code> is likely to change a lot before its first proper release.  This API page for ocelot.calculate is just a demo to help us make sure that <code>mkdocstrings</code> is working.</p>"},{"location":"api/calculate/#ocelot.calculate.position.mean_position","title":"<code>ocelot.calculate.position.mean_position(longitudes, latitudes, degrees=True)</code>","text":"<p>Calculates the spherical mean of angular positions, specified as longitudes and latitudes. This uses directional statistics to do so in a way that is aware of discontinuities, such as the fact that 0\u00b0 = 360\u00b0.</p> <p>Parameters:</p> Name Type Description Default <code>longitudes</code> <code>array - like</code> <p>Array of longitudinal positions of stars in your cluster (e.g. right ascensions or galactic longitudes.) Assumed to be in the range [0\u00b0, 360\u00b0].</p> required <code>latitudes</code> <code>array - like</code> <p>Array of latitudinal positions of stars in your cluster (e.g. declinations or  galactic latitudes.) Assumed to be in the range [-90\u00b0, 90\u00b0].</p> required <code>degrees</code> <code>bool</code> <p>Whether longitudes and latitudes are in degrees, and whether to return an answer in degrees. Defaults to True. If False, longitudes and latitudes are assumed to be in radians, with ranges [0, 2\u03c0] and [-\u03c0/2, \u03c0/2] respectively.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mean_longitude</code> <code>float</code> <code>mean_latitude</code> <code>float</code> Notes <p>This function explicitly assumes that your star cluster has a well-defined mean position. Some configurations (such as points uniformly distributed in at least one axis of a sphere) will not have a meaningful mean position.</p> <p>Internally, this function uses <code>scipy.stats.directional_stats</code>, with a definition taken from [1]. See [2] for more background.</p> References <p>[1] Mardia, Jupp. (2000). Directional Statistics (p. 163). Wiley. [2] https://en.wikipedia.org/wiki/Directional_statistics</p>"},{"location":"api/simulate/","title":"Simulate","text":"<p>See also: introductory tutorial on how to simulate a cluster.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedCluster","title":"<code>ocelot.simulate.cluster.SimulatedCluster</code>","text":"<p>A class for simulating and keeping track of a simulated cluster - including its original membership list and any observations simulated from it.</p> <p>This class is the main entry point in ocelot for simulating star clusters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>SimulatedClusterParameters or dict</code> <p>Parameters of the simulated cluster to generate. Should be a SimulatedClusterParameters object, but may also be a dict with keys for required parameters such as position, etc.</p> required <code>models</code> <code>(SimulatedClusterModels, dict or None)</code> <p>SimulatedClusterModels object or dict containing models used to overwrite or augment certain simulation features. Default: None</p> <code>None</code> <code>prune_simulated_cluster</code> <code>str</code> <p>Optional string used early during cluster simulation to prune a simulated cluster. Will be passed to pandas.DataFrame.query(). It can access parameters read directly from cluster isochrones, including magnitude, temperature, and luminosity. Default: \"\"</p> <code>''</code> <code>random_seed</code> <code>int or None</code> <p>Random seed to use for cluster generation. When set, cluster generation with the same seed should be identical. Default: None</p> <code>None</code> <code>features</code> <code>SimulatedClusterFeatures or dict or None</code> <p>A SimulatedClusterFeatures or dict object specifying features of cluster generation to turn off. Mostly intended to aid with testing. Default: None</p> <code>None</code> <code>observations</code> <code>list of str or None</code> <p>List of observations to generate. Soon to be deprecated; do not use.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>isochrone</code> <code>DataFrame</code> <p>Dataframe containing the isochrone used to simulate this cluster.</p> <code>cluster</code> <code>DataFrame</code> <p>Dataframe containing the true members of the cluster.</p> <code>observations</code> <code>dict of pd.DataFrame</code> <p>Dict of dataframes, with each one containing a different observation of the same cluster.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedCluster.make","title":"<code>make()</code>","text":"<p>Makes entire cluster according to specification set at initialization.</p> <p>This is the main function that should be used to simulate a cluster.</p> <p>Returns:</p> Type Description <code>SimulatedCluster</code> <p>A reference to the SimulatedCluster object.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedCluster.make_cluster","title":"<code>make_cluster()</code>","text":"<p>Creates the true stars and positions in a cluster.</p> <p>In general, just calling .make() is the recommended method for most users.</p> <p>Returns:</p> Type Description <code>SimulatedCluster</code> <p>A reference to the SimulatedCluster object.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedCluster.make_observations","title":"<code>make_observations()</code>","text":"<p>Makes all observations of the cluster.</p> <p>In general, just calling .make() is the recommended method for most users.</p> <p>Returns:</p> Type Description <code>SimulatedCluster</code> <p>A reference to the SimulatedCluster object.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedCluster.make_observation","title":"<code>make_observation(survey, seed=None)</code>","text":"<p>Makes one observation of the cluster.</p> <p>In general, just calling .make() is the recommended method for most users.</p> <p>Parameters:</p> Name Type Description Default <code>survey</code> <code>str</code> <p>Name of the survey (i.e. name in self.observations) to make.</p> required <code>seed</code> <code>None</code> <p>Seed used to reseed the random generator. Useful for doing multiple different simulated observations of the same cluster. May not be supported by all cluster observation models. Default: None, meaning that the current cluster random number generator generated from the seed specified during class initialization is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated cluster observation made by this method.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedClusterParameters","title":"<code>ocelot.simulate.cluster.SimulatedClusterParameters</code>  <code>dataclass</code>","text":"<p>Class for keeping track of parameters specified for a cluster to simulate.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>SkyCoord</code> <p>Position of the cluster as an astropy SkyCoord. Must have full 3D distance and 3D velocity information.</p> required <code>mass</code> <code>float</code> <p>Mass of the cluster in solar masses.</p> required <code>log_age</code> <code>float</code> <p>Age of the cluster in log (base 10) years.</p> required <code>metallicity</code> <code>float</code> <p>The metallicity of the cluster, [Fe/H].</p> required <code>r_core</code> <code>float</code> <p>The core radius of the cluster, in parsecs.</p> required <code>r_tidal</code> <code>float</code> <p>The tidal radius of the cluster, in parsecs.</p> required <code>extinction</code> <code>float</code> <p>The extinction (A_V / A_0) of the cluster in magnitudes.</p> required <code>differential_extinction</code> <code>float</code> <p>Amount of differential extinction to apply to the cluster, also in magnitudes. Default: 0.</p> <code>0.0</code> <code>minimum_stars</code> <code>int</code> <p>Specify the minimum number of stars the cluster can have. Default: 0</p> <code>1</code> <code>virial_ratio</code> <code>float</code> <p>Virial ratio of the cluster. Acts as a square-root scale factor to the cluster's velocity dispersion. Default: 0.5, meaning that the cluster is virialized.</p> <code>0.5</code> <code>eta_virial_ratio</code> <code>float</code> <p>Scale factor of the 1D velocity dispersion equation. Default: 10, which is a good approximation for most clusters.</p> <code>10.0</code> <code>id</code> <code>int</code> <p>ID of the simulated cluster. When set, this allows for unique identification of different simulated clusters. Default: 0.</p> <code>0</code> <p>Attributes:</p> Name Type Description <code>r_50</code> <code>float</code> <p>The half-light radius of the cluster in parsecs.</p> <code>velocity_dispersion_1d</code> <code>float</code> <p>The 1D velocity dispersion of the cluster in metres per second.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedClusterParameters.get_position_as_skycoord","title":"<code>get_position_as_skycoord(frame='icrs', with_zeroed_proper_motions=False)</code>","text":"<p>Returns the position of the cluster as a SkyCoord.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedClusterParameters.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts class (and all fields) to dict. Useful for saving information.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedClusterModels","title":"<code>ocelot.simulate.cluster.SimulatedClusterModels</code>  <code>dataclass</code>","text":"<p>Class for keeping track of all models that a generated SimulatedCluster will use.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>BaseClusterDistributionModel or None</code> <p>The distribution model for the cluster. Must be an instance of BaseClusterDistributionModel. Default: None, meaning that a King62 model is used</p> <code>None</code> <code>binaries</code> <code>BaseBinaryStarModel or None</code> <p>The binary star model for the cluster. Must be an instance of BaseBinaryStarModel. Default: None, meaning that a MoeDiStefanoMultiplicityRelation (with Duchene-Kraus+13 below 1 MSun) is used.</p> <code>None</code> <code>differential_reddening</code> <code>BaseDifferentialReddeningModel or None</code> <p>The differential reddening model for the cluster. Must be an instance of BaseDifferentialReddeningModel. Default: None, meaning that a FractalDifferentialReddening model is used.</p> <code>None</code> <code>observations</code> <code>list or tuple of BaseObservation</code> <p>A list or tuple of observation models for the cluster. Each model must be an instance of a BaseObservation. These observation models will be iterated through when generating cluster observations to generate as many (or few) observation simulations of a cluster as you'd like. Observation models must be unique. Default: None, meaning that no cluster observation simulation will be generated.</p> <code>tuple()</code> <p>Attributes:</p> Name Type Description <code>observations_dict</code> <code>dict of BaseObservation models</code> <p>Same as the observations parameter, but with observations instead organized into a dictionary.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedClusterModels.initialise_defaults","title":"<code>initialise_defaults(parameters, seed)</code>","text":"<p>For all class attributes, replace None values with sensible default models.</p> <p>This method is called during simulated cluster generation and should not need to be used by users.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>SimulatedClusterParameters</code> <p>The parameters of the cluster to simulate.</p> required <code>seed</code> <code>int</code> <p>Random seed to use for default models that incorporate randomness.</p> required"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedClusterModels.with_default_options","title":"<code>with_default_options(parameters, seed)</code>  <code>staticmethod</code>","text":"<p>Return an instance of a SimulatedClusterModels model with default options.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>SimulatedClusterParameters</code> <p>The parameters of the cluster to simulate.</p> required <code>seed</code> <code>int</code> <p>Random seed to use for default models that incorporate randomness.</p> required <p>Returns:</p> Type Description <code>SimulatedClusterModels</code> <p>An instance of SimulatedClusterModels with default options already set up.</p>"},{"location":"api/simulate/#ocelot.simulate.cluster.SimulatedClusterFeatures","title":"<code>ocelot.simulate.cluster.SimulatedClusterFeatures</code>  <code>dataclass</code>","text":"<p>Class for keeping track of all features used to simulate a cluster.</p> <p>This class mostly exists to aid in testing parts of ocelot.simulate with certain physical effects turned on or off.</p> <p>Parameters:</p> Name Type Description Default <code>binary_stars</code> <code>bool</code> <p>Whether or not to simulate binary stars in the cluster. Default: True</p> <code>True</code> <code>differential_extinction</code> <code>bool</code> <p>Whether or not to simulate differential extinction of the cluster. Default: True</p> <code>True</code> <code>selection_effects</code> <code>bool</code> <p>Whether or not to simulate selection effects in simulated observations of the cluster. Default: True</p> <code>True</code> <code>astrometric_uncertainties</code> <code>bool</code> <p>Whether or not to apply astrometric uncertainties to observations of the cluster. Default: True</p> <code>True</code> <code>photometric_uncertainties</code> <code>bool</code> <p>Whether or not to apply photometric uncertainties to observations of the cluster. Default: True</p> <code>True</code>"},{"location":"tutorials/binary_star_models/","title":"Binary star models","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom ocelot.model.binaries import moe_distefano_17, MoeDiStefanoMultiplicityRelation\n</pre> import numpy as np import matplotlib.pyplot as plt from ocelot.model.binaries import moe_distefano_17, MoeDiStefanoMultiplicityRelation In\u00a0[27]: Copied! <pre>masses, periods, periods_bounded, frequencies = (\n    moe_distefano_17.mass,\n    moe_distefano_17.mass_ratio_periods,\n    moe_distefano_17.mass_ratio_periods_with_bounds,\n    moe_distefano_17.period_frequencies,\n)\n</pre> masses, periods, periods_bounded, frequencies = (     moe_distefano_17.mass,     moe_distefano_17.mass_ratio_periods,     moe_distefano_17.mass_ratio_periods_with_bounds,     moe_distefano_17.period_frequencies, ) In\u00a0[4]: Copied! <pre>moe_distefano_17._get_mass_ratio_distribution_parameters(\n    masses, np.full_like(masses, 8)\n)\n</pre> moe_distefano_17._get_mass_ratio_distribution_parameters(     masses, np.full_like(masses, 8) ) Out[4]: <pre>(array([-1.1, -1.1, -1.1, -2. , -2. , -2. , -2. ]),\n array([ 0.3,  0.3,  0.3, -1. , -1.5, -1.5, -1.5]),\n array([0.015, 0.015, 0.015, 0.   , 0.   , 0.   , 0.   ]))</pre> In\u00a0[5]: Copied! <pre>x_pdf, y_pdf = moe_distefano_17._get_period_pdf(np.atleast_1d(16.0))\nppf, x = moe_distefano_17._get_period_percentile_point_function(np.asarray([16]))\nplt.plot(x, np.gradient(ppf.flatten(), x))\nplt.plot(x_pdf, y_pdf.flatten())\n</pre> x_pdf, y_pdf = moe_distefano_17._get_period_pdf(np.atleast_1d(16.0)) ppf, x = moe_distefano_17._get_period_percentile_point_function(np.asarray([16])) plt.plot(x, np.gradient(ppf.flatten(), x)) plt.plot(x_pdf, y_pdf.flatten()) Out[5]: <pre>[&lt;matplotlib.lines.Line2D at 0x7694def42ed0&gt;]</pre> In\u00a0[6]: Copied! <pre>x, y = moe_distefano_17._get_period_pdf(np.atleast_1d(16.0))\nppf, y1 = moe_distefano_17._get_period_percentile_point_function(np.atleast_1d(16.0))\nppf = ppf.flatten()\npp = moe_distefano_17._sample_period(np.full(100000, 16))\n_ = plt.hist(pp, bins=25, density=True)\nplt.plot(x, y.flatten())\nplt.plot(x, ppf / 5)\n# plt.plot(x, np.gradient(ppf, x))\n</pre> x, y = moe_distefano_17._get_period_pdf(np.atleast_1d(16.0)) ppf, y1 = moe_distefano_17._get_period_percentile_point_function(np.atleast_1d(16.0)) ppf = ppf.flatten() pp = moe_distefano_17._sample_period(np.full(100000, 16)) _ = plt.hist(pp, bins=25, density=True) plt.plot(x, y.flatten()) plt.plot(x, ppf / 5) # plt.plot(x, np.gradient(ppf, x)) Out[6]: <pre>[&lt;matplotlib.lines.Line2D at 0x7694de513d40&gt;]</pre> In\u00a0[7]: Copied! <pre>model = moe_distefano_17.MoeDiStefanoMultiplicityRelation()\n</pre> model = moe_distefano_17.MoeDiStefanoMultiplicityRelation() In\u00a0[8]: Copied! <pre>masses = np.random.uniform(low=0.1, high=20, size=100000)\n</pre> masses = np.random.uniform(low=0.1, high=20, size=100000) In\u00a0[10]: Copied! <pre>mass_ratio, period, eccentricity = model.random_binary(masses)\n</pre> mass_ratio, period, eccentricity = model.random_binary(masses) In\u00a0[\u00a0]: Copied! <pre>_ = plt.hist2d(mass_ratio, np.log10(period))\n</pre> _ = plt.hist2d(mass_ratio, np.log10(period)) In\u00a0[49]: Copied! <pre>_ = plt.hist2d(np.log10(period), eccentricity, bins=20)\n</pre> _ = plt.hist2d(np.log10(period), eccentricity, bins=20) In\u00a0[52]: Copied! <pre>np.random.seed(42)\nmodel.random_binary(masses[:10], seed=42)\n</pre> np.random.seed(42) model.random_binary(masses[:10], seed=42) Out[52]: <pre>(array([0.94394365, 0.66991325, 0.35863824, 0.26508398, 0.98930322,\n        0.20365471, 0.28866418]),\n array([3.17552947e+06, 3.92321260e+04, 1.12824477e+07, 3.38937128e+05,\n        1.20609031e+01, 5.05059564e+07, 3.46602403e+05]),\n array([0.87715898, 0.33014873, 0.29591527, 0.32269941, 0.33187267,\n        0.69890144, 0.62707649]))</pre> In\u00a0[53]: Copied! <pre>np.random.seed(42)\nmodel.random_binary(masses[:10], seed=42)\n</pre> np.random.seed(42) model.random_binary(masses[:10], seed=42) Out[53]: <pre>(array([0.94394365, 0.66991325, 0.35863824, 0.26508398, 0.98930322,\n        0.20365471, 0.28866418]),\n array([3.17552947e+06, 3.92321260e+04, 1.12824477e+07, 3.38937128e+05,\n        1.20609031e+01, 5.05059564e+07, 3.46602403e+05]),\n array([0.87715898, 0.33014873, 0.29591527, 0.32269941, 0.33187267,\n        0.69890144, 0.62707649]))</pre>"},{"location":"tutorials/binary_star_models/#binary-star-models","title":"Binary star models\u00b6","text":"<p>ocelot includes a number of models, one of which is a binary star model. Let's look at what it contains, as an example!</p>"},{"location":"tutorials/simulate_a_cluster/","title":"Simulate a cluster with ocelot","text":"<p>\u26a0 This feature is currently only available for simulating clusters in Gaia DR3 with PARSEC isochrones. More data types will be added soon!</p> <p>Ocelot includes many utilities for simulating clusters. They are designed to be flexible and 'hackable' for any science case!</p> <p>Let's quickly demonstrate how it works.</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom astropy.coordinates import SkyCoord\nfrom astropy import units as u\nfrom astroquery.gaia import Gaia\nfrom ocelot.simulate import (\n    SimulatedCluster,\n    SimulatedClusterParameters,\n    SimulatedClusterModels,\n)\nfrom ocelot.simulate.cluster import SimulatedClusterFeatures\nfrom ocelot.model.observation import (\n    GaiaDR3ObservationModel,\n    GenericSubsampleSelectionFunction,\n)\n</pre> import numpy as np import pandas as pd import matplotlib.pyplot as plt from astropy.coordinates import SkyCoord from astropy import units as u from astroquery.gaia import Gaia from ocelot.simulate import (     SimulatedCluster,     SimulatedClusterParameters,     SimulatedClusterModels, ) from ocelot.simulate.cluster import SimulatedClusterFeatures from ocelot.model.observation import (     GaiaDR3ObservationModel,     GenericSubsampleSelectionFunction, ) <p>We'll write a little function to plot our clusters:</p> In\u00a0[2]: Copied! <pre>def plot_on_axes(\n    ax, stars: pd.DataFrame, xlabel: str, ylabel: str, scatter_kwargs: dict\n):\n    ax.scatter(stars[xlabel], stars[ylabel], **scatter_kwargs)\n    ax.set(xlabel=xlabel, ylabel=ylabel)\n    ax.minorticks_on()\n\n\ndef plot_simulated_cluster(\n    cluster: SimulatedCluster | pd.DataFrame, observation: str = None, **kwargs\n):\n    fig, ax = plt.subplots(ncols=2, nrows=2, figsize=(6, 6), dpi=150)\n    ax = ax.flatten()\n\n    if observation is None:\n        stars = cluster.cluster\n        x_cmd = \"temperature\"\n        y_cmd = \"luminosity\"\n        ax[3].invert_xaxis()\n        ax[3].set(xscale=\"log\", yscale=\"log\")\n    elif observation == \"real\":\n        stars = cluster\n        x_cmd = \"bp_rp\"\n        y_cmd = \"phot_g_mean_mag\"\n        ax[3].invert_yaxis()\n    else:\n        stars = cluster.observations[observation]\n        stars[\"bp_rp\"] = stars[\"gaia_dr3_bp\"] - stars[\"gaia_dr3_rp\"]\n        x_cmd = \"bp_rp\"\n        y_cmd = \"gaia_dr3_g\"\n        ax[3].invert_yaxis()\n\n    # stars[\"bp_rp\"] = (\n    #     stars[\"phot_bp_mean_mag\"] - stars[\"phot_rp_mean_mag\"]\n    # )\n    scatter_kwargs = dict(s=1, color=\"k\")\n    scatter_kwargs.update(kwargs)\n    plot_on_axes(ax[0], stars, \"l\", \"b\", scatter_kwargs)\n    plot_on_axes(ax[1], stars, \"pmra\", \"pmdec\", scatter_kwargs)\n    plot_on_axes(ax[2], stars, \"l\", \"parallax\", scatter_kwargs)\n    plot_on_axes(ax[3], stars, x_cmd, y_cmd, scatter_kwargs)\n    fig.tight_layout()\n    return fig, ax\n</pre> def plot_on_axes(     ax, stars: pd.DataFrame, xlabel: str, ylabel: str, scatter_kwargs: dict ):     ax.scatter(stars[xlabel], stars[ylabel], **scatter_kwargs)     ax.set(xlabel=xlabel, ylabel=ylabel)     ax.minorticks_on()   def plot_simulated_cluster(     cluster: SimulatedCluster | pd.DataFrame, observation: str = None, **kwargs ):     fig, ax = plt.subplots(ncols=2, nrows=2, figsize=(6, 6), dpi=150)     ax = ax.flatten()      if observation is None:         stars = cluster.cluster         x_cmd = \"temperature\"         y_cmd = \"luminosity\"         ax[3].invert_xaxis()         ax[3].set(xscale=\"log\", yscale=\"log\")     elif observation == \"real\":         stars = cluster         x_cmd = \"bp_rp\"         y_cmd = \"phot_g_mean_mag\"         ax[3].invert_yaxis()     else:         stars = cluster.observations[observation]         stars[\"bp_rp\"] = stars[\"gaia_dr3_bp\"] - stars[\"gaia_dr3_rp\"]         x_cmd = \"bp_rp\"         y_cmd = \"gaia_dr3_g\"         ax[3].invert_yaxis()      # stars[\"bp_rp\"] = (     #     stars[\"phot_bp_mean_mag\"] - stars[\"phot_rp_mean_mag\"]     # )     scatter_kwargs = dict(s=1, color=\"k\")     scatter_kwargs.update(kwargs)     plot_on_axes(ax[0], stars, \"l\", \"b\", scatter_kwargs)     plot_on_axes(ax[1], stars, \"pmra\", \"pmdec\", scatter_kwargs)     plot_on_axes(ax[2], stars, \"l\", \"parallax\", scatter_kwargs)     plot_on_axes(ax[3], stars, x_cmd, y_cmd, scatter_kwargs)     fig.tight_layout()     return fig, ax <p>ocelot stores parameters about a simulated cluster internally with a class called <code>SimulatedClusterParameters</code>. You don't have to, but you can specify a new <code>SimulatedCluster</code> with this parameter class.</p> <p>This has the added bonus that the parameters for your cluster are fully type hinted, and get checked when you make them.</p> <p>To start, your cluster will need a position with full 3D position and velocity information, specified as an astropy SkyCoord.</p> In\u00a0[3]: Copied! <pre>position = SkyCoord(\n    ra=45 * u.deg,\n    dec=0 * u.deg,\n    distance=1000 * u.pc,\n    pm_ra_cosdec=10 * u.mas / u.yr,\n    pm_dec=0 * u.mas / u.yr,\n    radial_velocity=0 * u.km / u.s,\n    frame=\"icrs\",\n)\n</pre> position = SkyCoord(     ra=45 * u.deg,     dec=0 * u.deg,     distance=1000 * u.pc,     pm_ra_cosdec=10 * u.mas / u.yr,     pm_dec=0 * u.mas / u.yr,     radial_velocity=0 * u.km / u.s,     frame=\"icrs\", ) <p>We can then plug this position (and other parameters!) into the SimulatedClusterParameters class.</p> In\u00a0[4]: Copied! <pre>parameters = SimulatedClusterParameters(\n    position=position,\n    mass=1000,\n    log_age=8.0,\n    metallicity=0.2,\n    extinction=1.0,\n    r_core=2,\n    r_tidal=10,\n    virial_ratio=0.5\n)\n</pre> parameters = SimulatedClusterParameters(     position=position,     mass=1000,     log_age=8.0,     metallicity=0.2,     extinction=1.0,     r_core=2,     r_tidal=10,     virial_ratio=0.5 ) <p>ocelot actually tries to simulate clusters to be quite realistic from the get-go. So that we can gradually introduce new functionality, we'll turn some off using a special usually-just-for-testing parameter:</p> In\u00a0[5]: Copied! <pre>features = SimulatedClusterFeatures(\n    binary_stars=False,\n    astrometric_uncertainties=False,\n    photometric_uncertainties=False,\n    selection_effects=False\n)\n</pre> features = SimulatedClusterFeatures(     binary_stars=False,     astrometric_uncertainties=False,     photometric_uncertainties=False,     selection_effects=False ) <p>So! Let's simulate a basic cluster. We'll also set a <code>random_seed</code> for reproducibility.</p> In\u00a0[6]: Copied! <pre>cluster = SimulatedCluster(random_seed=42, parameters=parameters, features=features)\ncluster.make()\n_ = plot_simulated_cluster(cluster)\n</pre> cluster = SimulatedCluster(random_seed=42, parameters=parameters, features=features) cluster.make() _ = plot_simulated_cluster(cluster) <p>This successfully simulates the true positions, luminosities, and temperatures of stars in a simulated cluster that follows a King+62 profile. Great!</p> <p>The real challenge is to work out what their observed properties would actually be. This requires two more features that are the real chunky parts of <code>ocelot.simulate</code>:</p> <ol> <li>Pairing stars into binaries</li> <li>Modelling differential extinction</li> <li>Simulating an astrometric &amp; photometric observation.</li> </ol> <p>Now let's try adding in binary stars.</p> In\u00a0[7]: Copied! <pre>features = SimulatedClusterFeatures(\n    astrometric_uncertainties=False,\n    photometric_uncertainties=False,\n    selection_effects=False\n)\n</pre> features = SimulatedClusterFeatures(     astrometric_uncertainties=False,     photometric_uncertainties=False,     selection_effects=False ) In\u00a0[8]: Copied! <pre>cluster = SimulatedCluster(random_seed=42, parameters=parameters, features=features)\ncluster.make()\n_ = plot_simulated_cluster(cluster)\n</pre> cluster = SimulatedCluster(random_seed=42, parameters=parameters, features=features) cluster.make() _ = plot_simulated_cluster(cluster) <p>Nothing has changed - but behind the scenes, ocelot paired stars in our cluster into binaries. (It takes a bit longer to run the first time, as the code uses <code>numba</code> to compile some parts of the binary star code.)</p> <p>Right now, we're still just viewing an ideal cluster (imagine our telescope has infinite resolving power) - so we don't see and changes in the luminosity-temperature plot on the right.</p> <p>Nevertheless, many of our stars are now paired into binaries:</p> In\u00a0[9]: Copied! <pre>cluster.cluster.sample(n=10, random_state=42)[['simulated_id', 'index_primary']]\n</pre> cluster.cluster.sample(n=10, random_state=42)[['simulated_id', 'index_primary']] Out[9]: simulated_id index_primary 1241 1088 2456 203 209 2119 1260 1839 2037 1626 2076 -1 1578 1698 -1 102 688 236 2925 2982 -1 1582 857 -1 485 691 -1 1437 1516 2657 <p>For now, just one binary star relation is implemented - the Moe+17 relationships. ocelot does a lot of fancy stuff to do this - stars are paired together stochastically and placed on random orbits - meaning that binaries are also spatially positioned with their host stars!</p> <p>The next step is to simulate a real observation with a real telescope.</p> In\u00a0[10]: Copied! <pre>Gaia.ROW_LIMIT = 100000\nquery = Gaia.cone_search(parameters.position, radius=0.5 * u.deg)\ngaia_data = query.get_results().to_pandas().rename(columns={\"SOURCE_ID\": \"source_id\"})\n</pre> Gaia.ROW_LIMIT = 100000 query = Gaia.cone_search(parameters.position, radius=0.5 * u.deg) gaia_data = query.get_results().to_pandas().rename(columns={\"SOURCE_ID\": \"source_id\"}) <p>We then define a model for our observation and pass this data to <code>SimulatedCluster.make</code> - it will handle the rest:</p> In\u00a0[11]: Copied! <pre>models = SimulatedClusterModels(\n    observations=[GaiaDR3ObservationModel(representative_stars=gaia_data)]\n)\n\nfeatures = SimulatedClusterFeatures(\n    astrometric_uncertainties=False,\n    photometric_uncertainties=False,\n    selection_effects=False\n)\n\ncluster = SimulatedCluster(\n    random_seed=42, parameters=parameters, models=models, features=features\n)\ncluster.make()\n_ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\")\n</pre> models = SimulatedClusterModels(     observations=[GaiaDR3ObservationModel(representative_stars=gaia_data)] )  features = SimulatedClusterFeatures(     astrometric_uncertainties=False,     photometric_uncertainties=False,     selection_effects=False )  cluster = SimulatedCluster(     random_seed=42, parameters=parameters, models=models, features=features ) cluster.make() _ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\") <p>Our cluster now has unresolved binary stars and photometry!</p> <p>For unresolved binaries - look at the sequence on the right-hand side. This worked by using a (currently somewhat crude) estimate of Gaia's resolving power, and estimating which stars would or wouldn't become binaries.</p> In\u00a0[12]: Copied! <pre>models = SimulatedClusterModels(\n    observations=[GaiaDR3ObservationModel(representative_stars=gaia_data)]\n)\n\nfeatures = SimulatedClusterFeatures(selection_effects=False)\n\ncluster = SimulatedCluster(\n    random_seed=42, parameters=parameters, models=models, features=features\n)\ncluster.make()\n_ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\")\n</pre> models = SimulatedClusterModels(     observations=[GaiaDR3ObservationModel(representative_stars=gaia_data)] )  features = SimulatedClusterFeatures(selection_effects=False)  cluster = SimulatedCluster(     random_seed=42, parameters=parameters, models=models, features=features ) cluster.make() _ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\") <p>ocelot just used our sample of Gaia data to apply uncertainties to the stars in the cluster. Notice how the cluster now looks much larger in parallaxes and proper motions!</p> <p>Keen-eyed Gaia users will notice that our cluster continues down to magnitude 25 - far fainter than the Gaia magnitude limit of ~20.7. We should fix that!</p> <p>The final thing to make our cluster a bit more realistic is to apply selection effects.</p> <p>The Gaia selection function (i.e. a probabilistic magnitude limit) can be applied to our clusters, using the GaiaUnlimited selection function from Cantat-Gaudin+23.</p> In\u00a0[13]: Copied! <pre>models = SimulatedClusterModels(\n    observations=[GaiaDR3ObservationModel(representative_stars=gaia_data)]\n)\ncluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models)\ncluster.make()\n_ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\")\n</pre> models = SimulatedClusterModels(     observations=[GaiaDR3ObservationModel(representative_stars=gaia_data)] ) cluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models) cluster.make() _ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\") <p>Our cluster is now much less populous! There are lots of stars that Gaia can't see.</p> <p>This is a good place to stop if you're just looking for something really basic! However, ocelot is also able to add on a lot more additional functionality that we'll explore in the rest of this notebook.</p> <p>When working with Gaia data, it's common to do things like cut at a certain magnitude. In addition, many Gaia stars actually don't have proper motions and parallaxes, or have missing photometry in one or more bands.</p> <p>It's very common to cut Gaia data to only good samples of stars. ocelot can simulate what a cluster will look like after certain cuts!</p> <p>Internally, ocelot uses the method from Rix+21 &amp; Castro-Ginard+23 to model the probability that a given star would (or would not) be resolved in a subsample of a dataset.</p> <p>As a simple example, let's define a subset of our Gaia data that contains:</p> <ol> <li>Proper motions and parallaxes</li> <li>G, BP, and RP photometry</li> <li>A RUWE (renormalised weight error) greater than 1.4.</li> <li>Only stars greater than magnitude 19.</li> </ol> <p>So that ocelot can simulate this, we need to give it an example subsample of Gaia data. Let's use our region of real data around this cluster from before:</p> In\u00a0[14]: Copied! <pre>gaia_data_subsample = gaia_data.loc[\n    np.logical_and.reduce(\n        (\n            gaia_data[\"astrometric_params_solved\"] &gt;= 31,\n            gaia_data[\"phot_g_mean_mag\"].notna(),\n            gaia_data[\"phot_bp_mean_mag\"].notna(),\n            gaia_data[\"phot_rp_mean_mag\"].notna(),\n            gaia_data[\"ruwe\"] &lt; 1.4,\n            gaia_data[\"phot_g_mean_mag\"] &lt; 19,\n        )\n    )\n]\nprint(\n    f\"Fraction of stars in subsample: {len(gaia_data_subsample) / len(gaia_data):.2f}\"\n)\n</pre> gaia_data_subsample = gaia_data.loc[     np.logical_and.reduce(         (             gaia_data[\"astrometric_params_solved\"] &gt;= 31,             gaia_data[\"phot_g_mean_mag\"].notna(),             gaia_data[\"phot_bp_mean_mag\"].notna(),             gaia_data[\"phot_rp_mean_mag\"].notna(),             gaia_data[\"ruwe\"] &lt; 1.4,             gaia_data[\"phot_g_mean_mag\"] &lt; 19,         )     ) ] print(     f\"Fraction of stars in subsample: {len(gaia_data_subsample) / len(gaia_data):.2f}\" ) <pre>Fraction of stars in subsample: 0.40\n</pre> <p>Naively, our observed cluster should contain just 40% as many stars - most of which will be at the faint end.</p> <p>We can make a subsample quite easily, and ocelot has a class for that. We just need to pass it these two dataframes and the key we want to use (in this case, \"phot_g_mean_mag\" for the data, and \"gaia_dr3_g\" for the cluster.)</p> In\u00a0[15]: Copied! <pre>subsample_sf = GenericSubsampleSelectionFunction(\n    gaia_data, gaia_data_subsample, \"gaia_dr3_g\", column_in_data=\"phot_g_mean_mag\"\n)\n</pre> subsample_sf = GenericSubsampleSelectionFunction(     gaia_data, gaia_data_subsample, \"gaia_dr3_g\", column_in_data=\"phot_g_mean_mag\" ) <p>We can even take a quick look at what this selection function looks like.</p> In\u00a0[16]: Copied! <pre># Todo make plot\n</pre> # Todo make plot <p>And now, finally, here is our realistic final cluster:</p> In\u00a0[17]: Copied! <pre>models = SimulatedClusterModels(\n    observations=[\n        GaiaDR3ObservationModel(\n            representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]\n        )\n    ]\n)\n\ncluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models)\ncluster.make()\n_ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\")\n</pre> models = SimulatedClusterModels(     observations=[         GaiaDR3ObservationModel(             representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]         )     ] )  cluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models) cluster.make() _ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\") <p>Notice how there are far fewer stars than before applying these additional selection effects. In addition, the scatter in proper motion and parallax is a lot lower, as we've removed a lot of faint sources that (if Gaia even could measure their proper motion and parallax) would have very high uncertainty.</p> <p>Compare it to the full cluster membership list:</p> In\u00a0[18]: Copied! <pre>_ = plot_simulated_cluster(cluster)\n</pre> _ = plot_simulated_cluster(cluster) <p>Unsurprisingly, many stars are missing from Gaia for a cluster that's 1000 parsecs away.</p> <p>Dust in the Milky Way does not have a simple structure, and it's rare for a cluster that has extinction to not be differentially reddened to some extent - meaning that some stars have more extinction/reddening than others.</p> <p>Except for clusters extremely close to the Sun, dust maps are not really precise enough yet to be able to simulate the exact differential reddening across a given cluster. Instead, ocelot provides a way to approximate it with fractal (pink) noise.</p> <p>This is a feature that has been in our cluster all along - we just need to simulate a cluster with differential reddening enabled!</p> In\u00a0[19]: Copied! <pre>parameters.differential_extinction = 0.5\n</pre> parameters.differential_extinction = 0.5 In\u00a0[20]: Copied! <pre>models = SimulatedClusterModels(\n    observations=[\n        GaiaDR3ObservationModel(\n            representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]\n        )\n    ]\n)\n\ncluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models)\ncluster.make()\n_ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\")\n</pre> models = SimulatedClusterModels(     observations=[         GaiaDR3ObservationModel(             representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]         )     ] )  cluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models) cluster.make() _ = plot_simulated_cluster(cluster, observation=\"gaia_dr3\") <p>Note how the colour-magnitude diagram of our cluster is now much broader!</p> <p>It's quite cool to look at what has happened here behind the scenes. Let's plot extinction across the cluster:</p> In\u00a0[21]: Copied! <pre>fig, ax = plt.subplots(figsize=(3., 3.))\nobservation = cluster.observations['gaia_dr3']\npoints = ax.scatter(observation['l'], observation['b'], c=observation['extinction'])\nfig.colorbar(points, label=\"extinction\")\nax.set(xlabel=\"l\", ylabel=\"b\")\n</pre> fig, ax = plt.subplots(figsize=(3., 3.)) observation = cluster.observations['gaia_dr3'] points = ax.scatter(observation['l'], observation['b'], c=observation['extinction']) fig.colorbar(points, label=\"extinction\") ax.set(xlabel=\"l\", ylabel=\"b\") Out[21]: <pre>[Text(0.5, 0, 'l'), Text(0, 0.5, 'b')]</pre> <p>We set the differential extinction quite high here for demonstration purposes - but nevertheless, it has clearly added some quite different extinction across the cluster.</p> <p>Internally, ocelot actually generates a bespoke random fractal noise map depending on the seed we set for the cluster generation:</p> In\u00a0[22]: Copied! <pre>fig, ax = plt.subplots(figsize=(4, 4))\n\nax.imshow(cluster.models.differential_reddening._differential_extinction_map, origin=\"lower\")\n</pre> fig, ax = plt.subplots(figsize=(4, 4))  ax.imshow(cluster.models.differential_reddening._differential_extinction_map, origin=\"lower\") Out[22]: <pre>&lt;matplotlib.image.AxesImage at 0x7b5ff8d7bb00&gt;</pre> <p>This noise map ensures that differential reddening across a cluster is correlated - meaning one side of the cluster may be more reddened than the other, and we don't just add differential reddening randomly. This can have quite a bit of impact on how well you may see a certain part of a cluster - especially at high differential reddening.</p> <p>Without pruning:</p> In\u00a0[23]: Copied! <pre>%%timeit\nmodels = SimulatedClusterModels(\n    observations=[\n        GaiaDR3ObservationModel(\n            representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]\n        )\n    ]\n)\n\ncluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models)\ncluster.make()\n</pre> %%timeit models = SimulatedClusterModels(     observations=[         GaiaDR3ObservationModel(             representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]         )     ] )  cluster = SimulatedCluster(random_seed=42, parameters=parameters, models=models) cluster.make() <pre>638 ms \u00b1 20.9 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> <p>With pruning:</p> In\u00a0[24]: Copied! <pre>%%timeit\nmodels = SimulatedClusterModels(\n    observations=[\n        GaiaDR3ObservationModel(\n            representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]\n        )\n    ]\n)\n\ncluster = SimulatedCluster(\n    random_seed=42,\n    parameters=parameters,\n    models=models,\n    prune_simulated_cluster=\"gaia_dr3_g_true &lt; 21\",\n)\ncluster.make()\n</pre> %%timeit models = SimulatedClusterModels(     observations=[         GaiaDR3ObservationModel(             representative_stars=gaia_data, subsample_selection_functions=[subsample_sf]         )     ] )  cluster = SimulatedCluster(     random_seed=42,     parameters=parameters,     models=models,     prune_simulated_cluster=\"gaia_dr3_g_true &lt; 21\", ) cluster.make() <pre>289 ms \u00b1 11.8 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> <p>This can have a big impact on more distant clusters, where almost no stars are seen in Gaia.</p>"},{"location":"tutorials/simulate_a_cluster/#simulate-a-cluster-with-ocelot","title":"Simulate a cluster with ocelot\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#setup","title":"Setup\u00b6","text":"<p>Firstly, we'll need to import the relevant parts of the library.</p>"},{"location":"tutorials/simulate_a_cluster/#specifying-cluster-parameters","title":"Specifying cluster parameters\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#a-basic-simulated-cluster","title":"A basic simulated cluster\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#the-most-basic-possible","title":"The most basic possible\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#adding-in-binary-stars","title":"Adding in binary stars\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#simulating-a-basic-gaia-observation","title":"Simulating a basic Gaia observation\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#making-a-cluster-look-like-what-a-telescope-sees","title":"Making a cluster look like what a telescope sees\u00b6","text":"<p>The real power of ocelot comes from how we can simulate what a telescope would see if it looked at a cluster.</p> <p>Let's simulate a Gaia observation. Currently, we also need a bit of Gaia data to base error, selection etc. effects on around the cluster:</p>"},{"location":"tutorials/simulate_a_cluster/#adding-uncertainties","title":"Adding uncertainties\u00b6","text":"<p>Real Gaia data has errors! So we should add uncertainties, too.</p> <p>Here's what that looks like with errors switched on...</p>"},{"location":"tutorials/simulate_a_cluster/#accounting-for-selection-effects","title":"Accounting for selection effects\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#advanced-cluster-simulation","title":"Advanced cluster simulation\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#accounting-for-subsample-selection-effects","title":"Accounting for subsample selection effects\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#differential-reddening","title":"Differential reddening\u00b6","text":""},{"location":"tutorials/simulate_a_cluster/#simulation-pre-pruning","title":"Simulation pre-pruning\u00b6","text":"<p>Finally, one thing you can do with ocelot is to 'prune' your simulation of stars.</p> <p>By default, ocelot simulates all stars in a cluster, and then applies selection effects with your observation. However, if you know you don't care about a certain number of stars that will be invisible anyway (such as very faint ones), then you can 'pre-prune' your cluster and see a noticeable speedup. Here's an example:</p>"},{"location":"tutorials/tutorials/","title":"Tutorials","text":"<p>Coming soon!</p>"},{"location":"tutorials/tutorials/#work-in-progress","title":"Work in Progress","text":""}]}